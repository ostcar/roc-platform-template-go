app [makeGlue] {
    pf: platform "https://github.com/lukewilliamboswell/roc/releases/download/test/olBfrjtI-HycorWJMxdy7Dl2pcbbBoJy4mnSrDtRrlI.tar.br",
    glue: "https://github.com/lukewilliamboswell/roc-glue-code-gen/releases/download/0.2.0/UxzK668CtOpuhc_ipLgFC60pKqA7BVskJlHjEt7Snrg.tar.br",
    json: "https://github.com/lukewilliamboswell/roc-json/releases/download/0.10.0/KbIfTNbxShRX1A1FgXei1SpO5Jn8sgP6HP6PXbi-xyA.tar.br",
}

import pf.Types exposing [Types]
import pf.File exposing [File]
import pf.TypeId
import glue.Go
import json.Json

makeGlue : List Types -> Result (List File) Str
makeGlue = \types ->

    [
        # include the hardcoded builtins and functions to manage memory
        Go.builtins,

        # code gen using just the first
        List.first types
        |> Result.map \typesForArch -> [
            { name: "roc/glue.h", content: codeGenCTypes typesForArch },
            # { name: "roc/glue.go", content: codeGenGoTypes typesForArch },
        ]
        |> Result.withDefault [],

        # include the types encoded as JSON to assist with debugging
        List.first types
        |> Result.map \typesForArch -> [
            {
                name: "types.json",
                content: Encode.toBytes typesForArch Json.utf8
                |> Str.fromUtf8
                |> Result.withDefault "INVALID UTF8 ENCODED FROM JSON",
            },
        ]
        |> Result.withDefault [],

    ]
    |> List.join
    |> Ok

codeGenCTypes : Types -> Str
codeGenCTypes = \types ->

    typeShapes = Types.walkShapes types [] \decls, type, _id ->
        List.append decls type

    typeNames = List.map typeShapes \type ->
        when type is
            RocStr ->
                { name: "Str", def: "struct RocStr" }

            RocList _ ->
                { name: "List", def: "struct RocList" } # TODO: Give the list a better name

            Num size ->
                when size is
                    I32 -> { name: "I32", def: "long int" }
                    _ -> { name: "Unknown", def: "unknown number $(Inspect.toStr size)" }

            Unit -> { name: "Unit", def: "struct {}" }

            TagUnion (SingleTagStruct { tagName }) ->
                {name: "Tag$(tagName)", def: "struct $(tagName)"}

            _ -> { name: "Unknown", def: "Unknown $(Inspect.toStr type)" }

    idToName = \typeID ->
        id = TypeId.typeIDtoU64 typeID

        List.get typeNames id
        |> Result.withDefault { name: "invalid", def: "Invalid name, inknown type id $(Num.toStr id)" }

    declarations = List.walk typeShapes [] \decls, type ->

        decl = \new -> List.append decls new

        when type is
            TagUnion (SingleTagStruct { tagName, payload }) ->
                when payload is
                    HasNoClosure fields ->
                        fieldNames =
                            List.map fields \{ id } ->
                                idToName id
                                |> \s -> "    $(s.def);"
                            |> Str.joinWith "\n"

                        decl
                            """
                            struct $(tagName) {
                            $(fieldNames) 
                            };
                            """

                    _ -> decls # TODO

            RocResult okID errID ->
                ok = idToName okID
                err = idToName errID
                decl
                    """
                    struct Result$(ok.name)$(err.name) {
                        union {$(ok.def); $(err.def);} payload;
                        unsigned char disciminant;
                    };
                    """


            Unit
            | Unsized
            | EmptyTagUnion
            | Num _
            | Bool
            | RocStr
            | RocList _
            | RocBox _ ->
                decls

            _ -> decl "// Unsupported type not included $(Inspect.toStr type)"

    """
    // ⚠️ GENERATED CODE ⚠️
    //
    // generated by the `roc glue` CLI command
    //

    $(Str.joinWith declarations "\n\n")
    """

